Linux Booting Process

https://en.wikipedia.org/wiki/Linux_startup_process
https://www.ibm.com/developerworks/library/l-linuxboot/index.html

When does a shell get executed during the linux startup process
	https://unix.stackexchange.com/questions/118377/when-does-a-shell-get-executed-during-the-linux-startup-process

===== Overview ===== 

Early stages of the Linux startup process depend very much on the computer architecture. IBM PC compatible hardware is one architecture Linux is commonly used on; "on these systems, the BIOS plays an important role", which might not have exact analogs on other systems. In the following example, IBM PC compatible hardware is assumed:

1. The BIOS  basic input/output system (BIOS), which is stored in flash memory on the motherboard, performs startup tasks specific to the actual hardware platform. Once the hardware is enumerated and the hardware which is necessary for boot is initialized correctly, the BIOS loads and executes the boot code from the configured boot device.

2. The boot loader often presents the user with a menu of possible boot options and has a default option, which is selected after some time passes. Once the selection is made, the boot loader loads the kernel into memory, supplies it with some parameters and gives it control.
	- Boot loader Stage 1: MBR: loaded into RAM and executed. This boot loader is less than 512 bytes in length (a single sector), and its job is to load the second-stage boot loader.
	- Boot loader Stage 2: LILO/GRUB Boot Loader: When the second-stage boot loader is in RAM and executing, a splash screen is commonly displayed,
	=> Then Linux and an optional initial RAM disk (temporary root file system) are loaded into memory. When the images are loaded, the second-stage boot loader passes control to the kernel image and the kernel is decompressed and initialized

3. The kernel, if compressed, will decompress itself. It then sets up system functions such as essential hardware and memory paging, and calls start_kernel() which performs the majority of system setup (interrupts, the rest of memory management, device and driver initialization, etc.). It then starts up, separately, the idle process, scheduler, and the init process, which is executed in user space.

4. The init either consists of scripts that are executed by the shell (sysv, bsd, runit) or configuration files that are executed by the binary components (systemd, upstart). Init has specific levels (sysv, bsd) or targets (systemd), each of which consists of specific set of services (daemons). These provide various non-operating system services and structures and form the user environment. A typical server environment starts a web server, database services, and networking.

5. The typical desktop environment begins with a daemon, called the display manager, that starts a graphic environment which consists of a graphical server that provides a basic underlying graphical stack and a login manager that provides the ability to enter credentials and select a session. After the user has entered the correct credentials, the session manager starts a session. A session is a set of programs such as UI elements (panels, desktops, applets, etc.) which, together, can form a complete desktop environment.

On shutdown, init is called to close down all user space functionality in a controlled manner. The init then terminates and the kernel executes its own shutdown.

============ Details ===============
######## 1. BIOS(Basic Input/Output Startup)

In a PC, booting Linux begins in the BIOS at address 0xFFFF0. The first step of the BIOS is
the power-on self test (POST). The job of the POST is to perform a check of the hardware. The
second step of the BIOS is local device enumeration and initialization.

Given the different uses of BIOS functions, the BIOS is made up of two parts: the POST code and
runtime services. After the POST is complete, it is flushed from memory, but the BIOS runtime
services remain and are available to the target operating system.

To boot an operating system, the BIOS runtime searches for devices that are both active and
bootable in the order of preference defined by the complementary metal oxide semiconductor
(CMOS) settings. A boot device can be a floppy disk, a CD-ROM, a partition on a hard disk, a
device on the network, or even a USB flash memory stick.

Commonly, Linux is booted from a hard disk, where the Master Boot Record (MBR) contains the
primary boot loader. The MBR is a 512-byte sector, located in the first sector on the disk (sector 1
of cylinder 0, head 0). After the MBR is loaded into RAM, the BIOS yields control to it.

############ 2. Stage 1 boot loader
The primary boot loader that resides in the MBR is a 512-byte image containing both program
code and a small partition table (see Figure 2). The first 446 bytes are the primary boot loader,
which contains both executable code and error message text. The next sixty-four bytes are the
partition table, which contains a record for each of four partitions (sixteen bytes each)
The MBR ends with two bytes that are defined as the magic number (0xAA55). The magic number serves as
a validation check of the MBR.

The job of the primary boot loader is to find and load the secondary boot loader (stage 2). It does
this by looking through the partition table for an active partition. When it finds an active partition, it
scans the remaining partitions in the table to ensure that they're all inactive. When this is verified,
the active partition's boot record is read from the device into RAM and executed.

############ 3. Stage 2 boot loader
The secondary, or second-stage, boot loader could be more aptly called the kernel loader. The
task at this stage is to load the Linux kernel and optional initial RAM disk

The first- and second-stage boot loaders combined are called Linux Loader (LILO) or GRand
Unified Bootloader (GRUB) in the x86 PC environment. Because LILO has some disadvantages
that were corrected in GRUB, let's look into GRUB. 

The great thing about GRUB is that it includes knowledge of Linux file systems. Instead of using
raw sectors on the disk, as LILO does, GRUB can load a Linux kernel from an ext2 or ext3 file
system. 

With stage 2 loaded, GRUB can, upon request, display a list of available kernels (defined in /etc/
grub.conf, with soft links from /etc/grub/menu.lst and /etc/grub.conf). You can select a kernel
and even amend it with additional kernel parameters. Optionally, you can use a command-line
shell for greater manual control over the boot process.

With the second-stage boot loader in memory, the file system is consulted, and the default kernel
image and initrd image are loaded into memory. With the images ready, the stage 2 boot loader
invokes the kernel image

########## 4. Kernel 

------------------------------------------------------------------------------------------------
|Manual boot in GRUB
|From the GRUB command-line, you can boot a specific kernel with a named initrd image
|as follows:
|grub> kernel /bzImage-2.6.14.2
| [Linux-bzImage, setup=0x1400, size=0x29672e]
|grub> initrd /initrd-2.6.14.2.img
| [Linux-initrd @ 0x5f13000, 0xcc199 bytes]
|grub> boot
|Uncompressing Linux... Ok, booting the kernel.
|If you don't know the name of the kernel to boot, just type a forward slash (/) and press the
|Tab key. GRUB will display the list of kernels and initrd images.
------------------------------------------------------------------------------------------------

With the kernel image in memory and control given from the stage 2 boot loader, the kernel
stage begins. The kernel image isn't so much an executable kernel, but a compressed kernel
image. Typically this is a zImage (compressed image, less than 512KB) or a bzImage (big
compressed image, greater than 512KB), that has been previously compressed with zlib. At the
head of this kernel image is a routine that does some minimal amount of hardware setup and then
decompresses the kernel contained within the kernel image and places it into high memory. If an
initial RAM disk image is present, this routine moves it into memory and notes it for later use. The
routine then calls the kernel and the kernel boot begins.

During the boot of the kernel, the initial-RAM disk (initrd) that was loaded into memory by the
stage 2 boot loader is copied into RAM and mounted. This initrd serves as a temporary root file
system in RAM and allows the kernel to fully boot without having to mount any physical disks.
Since the necessary modules needed to interface with peripherals can be part of the initrd, the
kernel can be very small, but still support a large number of possible hardware configurations.
After the kernel is booted, the root file system is pivoted (via pivot_root) where the initrd root file
system is unmounted and the real root file system is mounted.

The initrd function allows you to create a small Linux kernel with drivers compiled as loadable
modules. These loadable modules give the kernel the means to access disks and the file systems
on those disks, as well as drivers for other hardware assets. Because the root file system is a file
system on a disk, the initrd function provides a means of bootstrapping to gain access to the disk
and mount the real root file system. In an embedded target without a hard disk, the initrd can be
the final root file system, or the final root file system can be mounted via the Network File System
(NFS).


The kernel in Linux handles all operating system processes, such as memory management, task scheduling, I/O, interprocess communication, and overall system control. This is loaded in two stages – in the first stage, the kernel (as a compressed image file) is loaded into memory and decompressed, and a few fundamental functions such as basic memory management are set up. Control is then switched one final time to the main kernel start process. Once the kernel is fully operational – and as part of its startup, upon being loaded and executing – the kernel looks for an init process to run, which (separately) sets up a user space and the processes needed for a user environment and ultimate login. The kernel itself is then allowed to go idle, subject to calls from other processes.


######### 5. Init process
A. SysV init

init is the parent of all processes on the system, it is executed by the kernel and is responsible for starting all other processes; it is the parent of all processes whose natural parents have died and it is responsible for reaping those when they die. Processes managed by init are known as jobs and are defined by files in the /etc/init directory.

Init's job is "to get everything running the way it should be"[7] once the kernel is fully running. Essentially it establishes and operates the entire user space. This includes checking and mounting file systems, starting up necessary user services, and ultimately switching to a user-environment when system startup is completed. 

It is similar to the Unix and BSD init processes, from which it derived, but in some cases has diverged or became customized. In a standard Linux system, Init is executed with a parameter, known as a runlevel, that takes a value from 0 to 6, and that determines which subsystems are to be made operational. Each runlevel has its own scripts which codify the various processes involved in setting up or leaving the given runlevel, and it is these scripts which are referenced as necessary in the boot process. Init scripts are typically held in directories with names such as "/etc/rc...". The top level configuration file for init is at /etc/inittab.[7]

During system boot, it checks whether a default runlevel is specified in /etc/inittab, and requests the runlevel to enter via the system console if not. It then proceeds to run all the relevant boot scripts for the given runlevel, including loading modules, checking the integrity of the root file system (which was mounted read-only) and then remounting it for full read-write access, and sets up the network.[4]

After it has spawned all of the processes specified, init goes dormant, and waits for one of three events to happen: processes that started to end or die, a power failure signal,[clarification needed] or a request via /sbin/telinit to further change the runlevel.[6]

This applies to SysV-style init.

B. systemd
Main article: systemd
The developers of systemd aimed to replace the Linux init system inherited from UNIX System V and Berkeley Software Distribution (BSD) operating systems. Like init, systemd is a daemon that manages other daemons. All daemons, including systemd, are background processes. Systemd is the first daemon to start (during booting) and the last daemon to terminate (during shutdown).

They wanted to improve the software framework for expressing dependencies, to allow more processing to be done in parallel during system booting, and to reduce the computational overhead of the shell.

Systemd's initialization instructions for each daemon are recorded in a declarative configuration file rather than a shell script.

C. Upstart
The traditional init process was originally only responsible for bringing the computer into a normal running state after power-on, or gracefully shutting down services prior to shutdown. As a result, the design is strictly synchronous, blocking future tasks until the current one has completed. Its tasks must also be defined in advance, as they are limited to this prep or cleanup function. This leaves it unable to handle various non-startup-tasks on a modern desktop computer.

Upstart operates asynchronously; it handles starting of the tasks and services during boot and stopping them during shutdown, and also supervises the tasks and services while the system is running.